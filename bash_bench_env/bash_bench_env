import json
from dataclasses import dataclass
from beartype import beartype

from .sandbox import DockerSandbox
from ..basic_agent_env.basic_agent_env import (
    BasicAgentEnv,
    BasicAgentState,
    Tool,
    Message,
)


@beartype
@dataclass
class BashTool(Tool):
    sandbox: DockerSandbox
    verbose: bool = False
    max_output_length: int = 1024

    def name(self) -> str:
        return "bash"

    def description(self) -> str:
        return "Execute bash code."

    def argument_description(self) -> str:
        return "Bash code to be executed."

    def _call(self, command: str) -> str:
        if self.verbose:
            print("\033[1;31mRUNNING COMMAND:\033[0m", command)

        result = self.sandbox.run_command(command)

        if self.verbose:
            print(f"\033[1;31mEXIT CODE: {result.returncode}\033[0m")
            print("\033[1;31mSTDOUT:\033[0m", result.stdout)
            print("\033[1;31mSTDOUT:\033[0m", result.stderr)

        return (
            f"<exit_code>{result.returncode}</exit_code>"
            f"<stdout>{self._truncate(result.stdout)}</stdout>"
            f"<stderr>{self._truncate(result.stderr)}</stderr>"
        )

    def _truncate(self, text: str) -> str:
        if len(text) <= self.max_output_length:
            return text
        return (
            text[: self.max_output_length // 2]
            + "[TRUNCATED]"
            + text[-self.max_output_length // 2 :]
        )


def tests_passed(sandbox: DockerSandbox, tests: str) -> bool:
    sandbox.run_command(f"cat << EOF > tests.py\n{tests}\nEOF")
    completed_process = sandbox.run_command("pytest testss.py")
    return completed_process.returncode == 0


@beartype
class BashBenchEnv(BasicAgentEnv):
    def get_tools(self, data: dict) -> list[Tool]:
        return [BashTool(sandbox=DockerSandbox())]

    def get_prompt(self, data: dict) -> str:
        return data["task_description"].removeprefix("Task: ")

    def get_reward(self, messages: list[Message], state: BasicAgentState) -> float:
        bash_tool = next(
            iter(tool for tool in state.tools if isinstance(tool, BashTool))
        )
        sandbox = bash_tool.sandbox

        public_tests_passed: bool = tests_passed(
            sandbox=sandbox, tests=state.data["public_tasts"]
        )
        private_tests_passed: bool = tests_passed(
            sandbox=sandbox, tests=state.data["private_tests"]
        )

        sandbox.cleanup()

        return (int(public_tests_passed) + int(private_tests_passed)) / 2


def main() -> None:
    with open("../bash-bench/valid_tasks.json", "r") as f:
        dataset = json.load(f)

    env = BashBenchEnv(
        full_data=dataset,
        sampling_params=None,
        vllm_engine=None,
    )
    state = env.init_state(dataset[0])
    message, state = env.get_next_prompt(messages=[], state=state)
    assert message is not None
    reward = env.get_reward(messages=[message], state=state)
    print(f"{reward=}")
